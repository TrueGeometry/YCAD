// chat.js
// Networking and Chat logic.

import { appState } from './state.js';
import { getMessageUrl } from './utils.js';
import { addMessageToChat, toggleLoading, addHistoryEntry } from './ui.js';
import { loadAndDisplayGLB, updateDesign, applyStateToObject } from './loader.js';
import { renderAttachments } from './chat-logic.js';
import { getSceneStructure } from './report.js';
import { captureAnnotatedImage } from './capture.js'; // Import from capture module

const chatInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');

export async function sendMessage(message) {
    toggleLoading(true);
    if(sendButton) sendButton.disabled = true;

    // 1. Capture the Current View (Annotated with component names)
    // captureAnnotatedImage returns a data URL of the scene with labels overlaid
    let autoGeneratedImage = captureAnnotatedImage();

    // 2. Combine with Manual Attachments
    const imagesToSend = [...appState.attachedImages];
    
    // Logic to prevent duplicate context:
    // Only add auto-generated image if it differs from the last manual attachment.
    // However, since we now annotate the auto-image, it will likely differ from a raw screenshot anyway.
    // We check purely for string equality to be safe, but conceptually the annotation makes it unique.
    if (autoGeneratedImage) {
        const lastManualImage = imagesToSend.length > 0 ? imagesToSend[imagesToSend.length - 1] : null;
        if (lastManualImage !== autoGeneratedImage) {
           // imagesToSend.push(autoGeneratedImage);
        }
    }

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 60000);

    try {
        const payload = { 
            message: message, 
            txt: appState.globalTxtValue,
            sessionid: appState.sessionId,
            images: imagesToSend,
            scene_structure: getSceneStructure() // Add structured report
        };
        
        // Backward compatibility: Set 'image' to the first manual one, or the auto one if none manual
        if (imagesToSend.length > 0) {
            payload.image = autoGeneratedImage;
        }

        const response = await fetch(getMessageUrl(), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        // Clear attachments after successful send (or attempt)
        appState.attachedImages = [];
        renderAttachments(); // Clear UI in main

        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json(); 

        if (data.reply) addMessageToChat('agent', data.reply);
        else {
            const signupUrl = 'https://www.truegeometry.com/pages/prod/sign-in.html';
            addMessageToChat('agent', `It looks like that requires an account. <a href="${signupUrl}" target="_blank" rel="noopener noreferrer">Please Sign Up here</a> to proceed.`);
        }

        if (data['3DglbV2File'] && typeof data['3DglbV2File'] === 'string') {
            // Modified to 'add' mode to append to existing scene instead of replacing
            loadAndDisplayGLB(data['3DglbV2File'], 'add');
        } else if (data.designUpdate && typeof data.designUpdate === 'object') {
            const appliedParams = updateDesign(data.designUpdate);
            if (appliedParams) addHistoryEntry(appliedParams, applyStateToObject);
        }

    } catch (error) {
        if (error.name === 'AbortError') {
            addMessageToChat('system', 'Request timed out (60s).');
        } else {
            console.error('Network Error:', error);
            addMessageToChat('system', 'Error communicating with the server.'); 
        }
    } finally {
        toggleLoading(false);
        if(sendButton && chatInput) {
             sendButton.disabled = !chatInput.value.trim(); 
             chatInput.focus();
        }
    }
}