// chat.js
// Networking and Chat logic.

import { appState } from './state.js';
import { getMessageUrl } from './utils.js';
import { addMessageToChat, toggleLoading, addHistoryEntry } from './ui.js';
import { loadAndDisplayGLB, updateDesign, applyStateToObject } from './loader.js';
import { renderAttachments } from './chat-logic.js';
import { getSceneStructure } from './report.js';
import { captureAnnotatedImage } from './capture.js'; // Import from capture module
import { executeCommand } from './commands.js'; 

const chatInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');

export async function sendMessage(message) {
    toggleLoading(true);
    if(sendButton) sendButton.disabled = true;

    // 1. Capture the Current View (Annotated with component names)
    // captureAnnotatedImage returns a data URL of the scene with labels overlaid
    let autoGeneratedImage = captureAnnotatedImage();

    // 2. Combine with Manual Attachments
    const imagesToSend = [...appState.attachedImages];
    
    // Logic to prevent duplicate context:
    // Only add auto-generated image if it differs from the last manual attachment.
    // However, since we now annotate the auto-image, it will likely differ from a raw screenshot anyway.
    // We check purely for string equality to be safe, but conceptually the annotation makes it unique.
    if (autoGeneratedImage) {
        const lastManualImage = imagesToSend.length > 0 ? imagesToSend[imagesToSend.length - 1] : null;
        if (lastManualImage !== autoGeneratedImage) {
           // imagesToSend.push(autoGeneratedImage);
        }
    }

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 60000);

    try {
        const payload = { 
            message: message, 
            txt: appState.globalTxtValue,
            sessionid: appState.sessionId,
            images: imagesToSend,
            scene_structure: getSceneStructure() // Add structured report
        };
        
        // Backward compatibility: Set 'image' to the first manual one, or the auto one if none manual
        if (imagesToSend.length > 0) {
            payload.image = autoGeneratedImage;
        }

        const response = await fetch(getMessageUrl(), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        // Clear attachments after successful send (or attempt)
        appState.attachedImages = [];
        renderAttachments(); // Clear UI in main

        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json(); 

        // Handle CAD Command Script from Server
        if (data.cad_command && data.reply) {
            addMessageToChat('system', 'ðŸ¤– <b>Executing Agent Script...</b>');
            
            let scriptContent = data.reply;
            
            // 1. Attempt to extract content from Markdown code blocks
            // Matches ```language\n content ``` or just ```\n content ```
            const codeBlockRegex = /```(?:[\w]*)(?:[\r\n]+)([\s\S]*?)```/g;
            const matches = [...scriptContent.matchAll(codeBlockRegex)];
            
            if (matches.length > 0) {
                // If code blocks found, only execute what's inside them
                scriptContent = matches.map(m => m[1]).join('\n');
            }

            const lines = scriptContent.split(/\r?\n/);
            for (const line of lines) {
                let cmd = line.trim();
                
                // 2. Clean Markdown list markers and quotes (e.g. "- ", "* ", "> ")
                cmd = cmd.replace(/^[\s]*[->*]\s+/, '');

                // 3. Clean inline code backticks (e.g. `/move` or just `move`)
                cmd = cmd.replace(/`/g, '');

                // 4. Filter comments and empty lines
                if (!cmd || cmd.startsWith('//') || cmd.startsWith('#')) continue;

                // 5. Robust Slash Handling: Remove ALL leading slashes, then add exactly one.
                // This prevents double slashes (e.g. //move) if the model adds one and we add another,
                // or handles cases where the model forgets the slash.
                const cleanCmd = cmd.replace(/^[\/]+/, '');
                const commandToRun = '/' + cleanCmd;
                
                addMessageToChat('system', `<span style="color:#2563eb; font-family:monospace;">> ${commandToRun}</span>`);
                await executeCommand(commandToRun);
                
                // Small delay for UI updates
                await new Promise(r => setTimeout(r, 100)); 
            }
            addMessageToChat('system', 'âœ… Execution complete.');
        } 
        else {
            // Standard Flow: Text Reply + Optional GLB/Updates
            if (data.reply) {
                addMessageToChat('agent', data.reply);
            }
            else {
                const signupUrl = 'https://www.truegeometry.com/pages/prod/sign-in.html';
                addMessageToChat('agent', `It looks like that requires an account. <a href="${signupUrl}" target="_blank" rel="noopener noreferrer">Please Sign Up here</a> to proceed.`);
            }

            if (data['3DglbV2File'] && typeof data['3DglbV2File'] === 'string') {
                // Modified to 'add' mode to append to existing scene instead of replacing
                loadAndDisplayGLB(data['3DglbV2File'], 'add');
            } else if (data.designUpdate && typeof data.designUpdate === 'object') {
                const appliedParams = updateDesign(data.designUpdate);
                if (appliedParams) addHistoryEntry(appliedParams, applyStateToObject);
            }
        }

    } catch (error) {
        if (error.name === 'AbortError') {
            addMessageToChat('system', 'Request timed out (60s).');
        } else {
            console.error('Network Error:', error);
            addMessageToChat('system', 'Error communicating with the server.'); 
        }
    } finally {
        toggleLoading(false);
        if(sendButton && chatInput) {
             sendButton.disabled = !chatInput.value.trim(); 
             chatInput.focus();
        }
    }
}